/* automatically generated by rust-bindgen 0.69.4 */

pub type ASensorType = _bindgen_ty_4;
pub type ALooperEvent = _bindgen_ty_3;
pub type ALooperPoll = _bindgen_ty_2;

pub type ALooper_callbackFunc = ::core::option::Option<
    unsafe extern "C" fn(
        fd: libc::c_int,
        events: libc::c_int,
        data: *mut libc::c_void,
    ) -> libc::c_int,
>;
pub type ASensorRef = *const ASensor;
pub type ASensorList = *const ASensorRef;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ALooper {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AHardwareBuffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ASensorVector {
    pub __bindgen_anon_1: ASensorVector__bindgen_ty_1,
    pub status: i8,
    pub reserved: [u8; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASensorVector__bindgen_ty_1__bindgen_ty_1 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASensorVector__bindgen_ty_1__bindgen_ty_2 {
    pub azimuth: f32,
    pub pitch: f32,
    pub roll: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AMetaDataEvent {
    pub what: i32,
    pub sensor: i32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AUncalibratedEvent {
    pub __bindgen_anon_1: AUncalibratedEvent__bindgen_ty_1,
    pub __bindgen_anon_2: AUncalibratedEvent__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AUncalibratedEvent__bindgen_ty_1__bindgen_ty_1 {
    pub x_uncalib: f32,
    pub y_uncalib: f32,
    pub z_uncalib: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AUncalibratedEvent__bindgen_ty_2__bindgen_ty_1 {
    pub x_bias: f32,
    pub y_bias: f32,
    pub z_bias: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AHeartRateEvent {
    pub bpm: f32,
    pub status: i8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ADynamicSensorEvent {
    pub connected: i32,
    pub handle: i32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AAdditionalInfoEvent {
    pub type_: i32,
    pub serial: i32,
    pub __bindgen_anon_1: AAdditionalInfoEvent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AHeadTrackerEvent {
    pub rx: f32,
    pub ry: f32,
    pub rz: f32,
    pub vx: f32,
    pub vy: f32,
    pub vz: f32,
    pub discontinuity_count: i32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ALimitedAxesImuEvent {
    pub __bindgen_anon_1: ALimitedAxesImuEvent__bindgen_ty_1,
    pub __bindgen_anon_2: ALimitedAxesImuEvent__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ALimitedAxesImuEvent__bindgen_ty_1__bindgen_ty_1 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ALimitedAxesImuEvent__bindgen_ty_2__bindgen_ty_1 {
    pub x_supported: f32,
    pub y_supported: f32,
    pub z_supported: f32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ALimitedAxesImuUncalibratedEvent {
    pub __bindgen_anon_1: ALimitedAxesImuUncalibratedEvent__bindgen_ty_1,
    pub __bindgen_anon_2: ALimitedAxesImuUncalibratedEvent__bindgen_ty_2,
    pub __bindgen_anon_3: ALimitedAxesImuUncalibratedEvent__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ALimitedAxesImuUncalibratedEvent__bindgen_ty_1__bindgen_ty_1 {
    pub x_uncalib: f32,
    pub y_uncalib: f32,
    pub z_uncalib: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ALimitedAxesImuUncalibratedEvent__bindgen_ty_2__bindgen_ty_1 {
    pub x_bias: f32,
    pub y_bias: f32,
    pub z_bias: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ALimitedAxesImuUncalibratedEvent__bindgen_ty_3__bindgen_ty_1 {
    pub x_supported: f32,
    pub y_supported: f32,
    pub z_supported: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AHeadingEvent {
    pub heading: f32,
    pub accuracy: f32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ASensorEvent {
    pub version: i32,
    pub sensor: i32,
    pub type_: i32,
    pub reserved0: i32,
    pub timestamp: i64,
    pub __bindgen_anon_1: ASensorEvent__bindgen_ty_1,
    pub flags: u32,
    pub reserved1: [i32; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASensorManager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASensorEventQueue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASensor {
    _unused: [u8; 0],
}
pub const ASENSOR_FIFO_COUNT_INVALID: i32 = -1;
pub const ASENSOR_DELAY_INVALID: i32 = -2147483648;
pub const ASENSOR_INVALID: i32 = -1;
pub const ASENSOR_STANDARD_GRAVITY: f64 = 9.80665;
pub const ASENSOR_MAGNETIC_FIELD_EARTH_MAX: f64 = 60.0;
pub const ASENSOR_MAGNETIC_FIELD_EARTH_MIN: f64 = 30.0;
pub const ALOOPER_PREPARE_ALLOW_NON_CALLBACKS: _bindgen_ty_1 =
    _bindgen_ty_1::ALOOPER_PREPARE_ALLOW_NON_CALLBACKS;
pub const ALOOPER_POLL_WAKE: _bindgen_ty_2 = _bindgen_ty_2::ALOOPER_POLL_WAKE;
pub const ALOOPER_POLL_CALLBACK: _bindgen_ty_2 = _bindgen_ty_2::ALOOPER_POLL_CALLBACK;
pub const ALOOPER_POLL_TIMEOUT: _bindgen_ty_2 = _bindgen_ty_2::ALOOPER_POLL_TIMEOUT;
pub const ALOOPER_POLL_ERROR: _bindgen_ty_2 = _bindgen_ty_2::ALOOPER_POLL_ERROR;
pub const ALOOPER_EVENT_INPUT: _bindgen_ty_3 = _bindgen_ty_3::ALOOPER_EVENT_INPUT;
pub const ALOOPER_EVENT_OUTPUT: _bindgen_ty_3 = _bindgen_ty_3::ALOOPER_EVENT_OUTPUT;
pub const ALOOPER_EVENT_ERROR: _bindgen_ty_3 = _bindgen_ty_3::ALOOPER_EVENT_ERROR;
pub const ALOOPER_EVENT_HANGUP: _bindgen_ty_3 = _bindgen_ty_3::ALOOPER_EVENT_HANGUP;
pub const ALOOPER_EVENT_INVALID: _bindgen_ty_3 = _bindgen_ty_3::ALOOPER_EVENT_INVALID;
pub const ASENSOR_TYPE_INVALID: _bindgen_ty_4 = _bindgen_ty_4::ASENSOR_TYPE_INVALID;
pub const ASENSOR_TYPE_ACCELEROMETER: _bindgen_ty_4 = _bindgen_ty_4::ASENSOR_TYPE_ACCELEROMETER;
pub const ASENSOR_TYPE_MAGNETIC_FIELD: _bindgen_ty_4 = _bindgen_ty_4::ASENSOR_TYPE_MAGNETIC_FIELD;
pub const ASENSOR_TYPE_GYROSCOPE: _bindgen_ty_4 = _bindgen_ty_4::ASENSOR_TYPE_GYROSCOPE;
pub const ASENSOR_TYPE_LIGHT: _bindgen_ty_4 = _bindgen_ty_4::ASENSOR_TYPE_LIGHT;
pub const ASENSOR_TYPE_PRESSURE: _bindgen_ty_4 = _bindgen_ty_4::ASENSOR_TYPE_PRESSURE;
pub const ASENSOR_TYPE_PROXIMITY: _bindgen_ty_4 = _bindgen_ty_4::ASENSOR_TYPE_PROXIMITY;
pub const ASENSOR_TYPE_GRAVITY: _bindgen_ty_4 = _bindgen_ty_4::ASENSOR_TYPE_GRAVITY;
pub const ASENSOR_TYPE_LINEAR_ACCELERATION: _bindgen_ty_4 =
    _bindgen_ty_4::ASENSOR_TYPE_LINEAR_ACCELERATION;
pub const ASENSOR_TYPE_ROTATION_VECTOR: _bindgen_ty_4 = _bindgen_ty_4::ASENSOR_TYPE_ROTATION_VECTOR;
pub const ASENSOR_TYPE_RELATIVE_HUMIDITY: _bindgen_ty_4 =
    _bindgen_ty_4::ASENSOR_TYPE_RELATIVE_HUMIDITY;
pub const ASENSOR_TYPE_AMBIENT_TEMPERATURE: _bindgen_ty_4 =
    _bindgen_ty_4::ASENSOR_TYPE_AMBIENT_TEMPERATURE;
pub const ASENSOR_TYPE_MAGNETIC_FIELD_UNCALIBRATED: _bindgen_ty_4 =
    _bindgen_ty_4::ASENSOR_TYPE_MAGNETIC_FIELD_UNCALIBRATED;
pub const ASENSOR_TYPE_GAME_ROTATION_VECTOR: _bindgen_ty_4 =
    _bindgen_ty_4::ASENSOR_TYPE_GAME_ROTATION_VECTOR;
pub const ASENSOR_TYPE_GYROSCOPE_UNCALIBRATED: _bindgen_ty_4 =
    _bindgen_ty_4::ASENSOR_TYPE_GYROSCOPE_UNCALIBRATED;
pub const ASENSOR_TYPE_SIGNIFICANT_MOTION: _bindgen_ty_4 =
    _bindgen_ty_4::ASENSOR_TYPE_SIGNIFICANT_MOTION;
pub const ASENSOR_TYPE_STEP_DETECTOR: _bindgen_ty_4 = _bindgen_ty_4::ASENSOR_TYPE_STEP_DETECTOR;
pub const ASENSOR_TYPE_STEP_COUNTER: _bindgen_ty_4 = _bindgen_ty_4::ASENSOR_TYPE_STEP_COUNTER;
pub const ASENSOR_TYPE_GEOMAGNETIC_ROTATION_VECTOR: _bindgen_ty_4 =
    _bindgen_ty_4::ASENSOR_TYPE_GEOMAGNETIC_ROTATION_VECTOR;
pub const ASENSOR_TYPE_HEART_RATE: _bindgen_ty_4 = _bindgen_ty_4::ASENSOR_TYPE_HEART_RATE;
pub const ASENSOR_TYPE_POSE_6DOF: _bindgen_ty_4 = _bindgen_ty_4::ASENSOR_TYPE_POSE_6DOF;
pub const ASENSOR_TYPE_STATIONARY_DETECT: _bindgen_ty_4 =
    _bindgen_ty_4::ASENSOR_TYPE_STATIONARY_DETECT;
pub const ASENSOR_TYPE_MOTION_DETECT: _bindgen_ty_4 = _bindgen_ty_4::ASENSOR_TYPE_MOTION_DETECT;
pub const ASENSOR_TYPE_HEART_BEAT: _bindgen_ty_4 = _bindgen_ty_4::ASENSOR_TYPE_HEART_BEAT;
pub const ASENSOR_TYPE_DYNAMIC_SENSOR_META: _bindgen_ty_4 =
    _bindgen_ty_4::ASENSOR_TYPE_DYNAMIC_SENSOR_META;
pub const ASENSOR_TYPE_ADDITIONAL_INFO: _bindgen_ty_4 = _bindgen_ty_4::ASENSOR_TYPE_ADDITIONAL_INFO;
pub const ASENSOR_TYPE_LOW_LATENCY_OFFBODY_DETECT: _bindgen_ty_4 =
    _bindgen_ty_4::ASENSOR_TYPE_LOW_LATENCY_OFFBODY_DETECT;
pub const ASENSOR_TYPE_ACCELEROMETER_UNCALIBRATED: _bindgen_ty_4 =
    _bindgen_ty_4::ASENSOR_TYPE_ACCELEROMETER_UNCALIBRATED;
pub const ASENSOR_TYPE_HINGE_ANGLE: _bindgen_ty_4 = _bindgen_ty_4::ASENSOR_TYPE_HINGE_ANGLE;
pub const ASENSOR_TYPE_HEAD_TRACKER: _bindgen_ty_4 = _bindgen_ty_4::ASENSOR_TYPE_HEAD_TRACKER;
pub const ASENSOR_TYPE_ACCELEROMETER_LIMITED_AXES: _bindgen_ty_4 =
    _bindgen_ty_4::ASENSOR_TYPE_ACCELEROMETER_LIMITED_AXES;
pub const ASENSOR_TYPE_GYROSCOPE_LIMITED_AXES: _bindgen_ty_4 =
    _bindgen_ty_4::ASENSOR_TYPE_GYROSCOPE_LIMITED_AXES;
pub const ASENSOR_TYPE_ACCELEROMETER_LIMITED_AXES_UNCALIBRATED: _bindgen_ty_4 =
    _bindgen_ty_4::ASENSOR_TYPE_ACCELEROMETER_LIMITED_AXES_UNCALIBRATED;
pub const ASENSOR_TYPE_GYROSCOPE_LIMITED_AXES_UNCALIBRATED: _bindgen_ty_4 =
    _bindgen_ty_4::ASENSOR_TYPE_GYROSCOPE_LIMITED_AXES_UNCALIBRATED;
pub const ASENSOR_TYPE_HEADING: _bindgen_ty_4 = _bindgen_ty_4::ASENSOR_TYPE_HEADING;
pub const ASENSOR_STATUS_NO_CONTACT: _bindgen_ty_5 = _bindgen_ty_5::ASENSOR_STATUS_NO_CONTACT;
pub const ASENSOR_STATUS_UNRELIABLE: _bindgen_ty_5 = _bindgen_ty_5::ASENSOR_STATUS_UNRELIABLE;
pub const ASENSOR_STATUS_ACCURACY_LOW: _bindgen_ty_5 = _bindgen_ty_5::ASENSOR_STATUS_ACCURACY_LOW;
pub const ASENSOR_STATUS_ACCURACY_MEDIUM: _bindgen_ty_5 =
    _bindgen_ty_5::ASENSOR_STATUS_ACCURACY_MEDIUM;
pub const ASENSOR_STATUS_ACCURACY_HIGH: _bindgen_ty_5 = _bindgen_ty_5::ASENSOR_STATUS_ACCURACY_HIGH;
pub const AREPORTING_MODE_INVALID: _bindgen_ty_6 = _bindgen_ty_6::AREPORTING_MODE_INVALID;
pub const AREPORTING_MODE_CONTINUOUS: _bindgen_ty_6 = _bindgen_ty_6::AREPORTING_MODE_CONTINUOUS;
pub const AREPORTING_MODE_ON_CHANGE: _bindgen_ty_6 = _bindgen_ty_6::AREPORTING_MODE_ON_CHANGE;
pub const AREPORTING_MODE_ONE_SHOT: _bindgen_ty_6 = _bindgen_ty_6::AREPORTING_MODE_ONE_SHOT;
pub const AREPORTING_MODE_SPECIAL_TRIGGER: _bindgen_ty_6 =
    _bindgen_ty_6::AREPORTING_MODE_SPECIAL_TRIGGER;
pub const ASENSOR_DIRECT_RATE_STOP: _bindgen_ty_7 = _bindgen_ty_7::ASENSOR_DIRECT_RATE_STOP;
pub const ASENSOR_DIRECT_RATE_NORMAL: _bindgen_ty_7 = _bindgen_ty_7::ASENSOR_DIRECT_RATE_NORMAL;
pub const ASENSOR_DIRECT_RATE_FAST: _bindgen_ty_7 = _bindgen_ty_7::ASENSOR_DIRECT_RATE_FAST;
pub const ASENSOR_DIRECT_RATE_VERY_FAST: _bindgen_ty_7 =
    _bindgen_ty_7::ASENSOR_DIRECT_RATE_VERY_FAST;
pub const ASENSOR_DIRECT_CHANNEL_TYPE_SHARED_MEMORY: _bindgen_ty_8 =
    _bindgen_ty_8::ASENSOR_DIRECT_CHANNEL_TYPE_SHARED_MEMORY;
pub const ASENSOR_DIRECT_CHANNEL_TYPE_HARDWARE_BUFFER: _bindgen_ty_8 =
    _bindgen_ty_8::ASENSOR_DIRECT_CHANNEL_TYPE_HARDWARE_BUFFER;
pub const ASENSOR_ADDITIONAL_INFO_BEGIN: _bindgen_ty_9 =
    _bindgen_ty_9::ASENSOR_ADDITIONAL_INFO_BEGIN;
pub const ASENSOR_ADDITIONAL_INFO_END: _bindgen_ty_9 = _bindgen_ty_9::ASENSOR_ADDITIONAL_INFO_END;
pub const ASENSOR_ADDITIONAL_INFO_UNTRACKED_DELAY: _bindgen_ty_9 =
    _bindgen_ty_9::ASENSOR_ADDITIONAL_INFO_UNTRACKED_DELAY;
pub const ASENSOR_ADDITIONAL_INFO_INTERNAL_TEMPERATURE: _bindgen_ty_9 =
    _bindgen_ty_9::ASENSOR_ADDITIONAL_INFO_INTERNAL_TEMPERATURE;
pub const ASENSOR_ADDITIONAL_INFO_VEC3_CALIBRATION: _bindgen_ty_9 =
    _bindgen_ty_9::ASENSOR_ADDITIONAL_INFO_VEC3_CALIBRATION;
pub const ASENSOR_ADDITIONAL_INFO_SENSOR_PLACEMENT: _bindgen_ty_9 =
    _bindgen_ty_9::ASENSOR_ADDITIONAL_INFO_SENSOR_PLACEMENT;
pub const ASENSOR_ADDITIONAL_INFO_SAMPLING: _bindgen_ty_9 =
    _bindgen_ty_9::ASENSOR_ADDITIONAL_INFO_SAMPLING;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_1 {
    ALOOPER_PREPARE_ALLOW_NON_CALLBACKS = 1,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_2 {
    ALOOPER_POLL_WAKE = -1,
    ALOOPER_POLL_CALLBACK = -2,
    ALOOPER_POLL_TIMEOUT = -3,
    ALOOPER_POLL_ERROR = -4,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_3 {
    ALOOPER_EVENT_INPUT = 1,
    ALOOPER_EVENT_OUTPUT = 2,
    ALOOPER_EVENT_ERROR = 4,
    ALOOPER_EVENT_HANGUP = 8,
    ALOOPER_EVENT_INVALID = 16,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_4 {
    ASENSOR_TYPE_INVALID = -1,
    ASENSOR_TYPE_ACCELEROMETER = 1,
    ASENSOR_TYPE_MAGNETIC_FIELD = 2,
    ASENSOR_TYPE_GYROSCOPE = 4,
    ASENSOR_TYPE_LIGHT = 5,
    ASENSOR_TYPE_PRESSURE = 6,
    ASENSOR_TYPE_PROXIMITY = 8,
    ASENSOR_TYPE_GRAVITY = 9,
    ASENSOR_TYPE_LINEAR_ACCELERATION = 10,
    ASENSOR_TYPE_ROTATION_VECTOR = 11,
    ASENSOR_TYPE_RELATIVE_HUMIDITY = 12,
    ASENSOR_TYPE_AMBIENT_TEMPERATURE = 13,
    ASENSOR_TYPE_MAGNETIC_FIELD_UNCALIBRATED = 14,
    ASENSOR_TYPE_GAME_ROTATION_VECTOR = 15,
    ASENSOR_TYPE_GYROSCOPE_UNCALIBRATED = 16,
    ASENSOR_TYPE_SIGNIFICANT_MOTION = 17,
    ASENSOR_TYPE_STEP_DETECTOR = 18,
    ASENSOR_TYPE_STEP_COUNTER = 19,
    ASENSOR_TYPE_GEOMAGNETIC_ROTATION_VECTOR = 20,
    ASENSOR_TYPE_HEART_RATE = 21,
    ASENSOR_TYPE_POSE_6DOF = 28,
    ASENSOR_TYPE_STATIONARY_DETECT = 29,
    ASENSOR_TYPE_MOTION_DETECT = 30,
    ASENSOR_TYPE_HEART_BEAT = 31,
    ASENSOR_TYPE_DYNAMIC_SENSOR_META = 32,
    ASENSOR_TYPE_ADDITIONAL_INFO = 33,
    ASENSOR_TYPE_LOW_LATENCY_OFFBODY_DETECT = 34,
    ASENSOR_TYPE_ACCELEROMETER_UNCALIBRATED = 35,
    ASENSOR_TYPE_HINGE_ANGLE = 36,
    ASENSOR_TYPE_HEAD_TRACKER = 37,
    ASENSOR_TYPE_ACCELEROMETER_LIMITED_AXES = 38,
    ASENSOR_TYPE_GYROSCOPE_LIMITED_AXES = 39,
    ASENSOR_TYPE_ACCELEROMETER_LIMITED_AXES_UNCALIBRATED = 40,
    ASENSOR_TYPE_GYROSCOPE_LIMITED_AXES_UNCALIBRATED = 41,
    ASENSOR_TYPE_HEADING = 42,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_5 {
    ASENSOR_STATUS_NO_CONTACT = -1,
    ASENSOR_STATUS_UNRELIABLE = 0,
    ASENSOR_STATUS_ACCURACY_LOW = 1,
    ASENSOR_STATUS_ACCURACY_MEDIUM = 2,
    ASENSOR_STATUS_ACCURACY_HIGH = 3,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_6 {
    AREPORTING_MODE_INVALID = -1,
    AREPORTING_MODE_CONTINUOUS = 0,
    AREPORTING_MODE_ON_CHANGE = 1,
    AREPORTING_MODE_ONE_SHOT = 2,
    AREPORTING_MODE_SPECIAL_TRIGGER = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_7 {
    ASENSOR_DIRECT_RATE_STOP = 0,
    ASENSOR_DIRECT_RATE_NORMAL = 1,
    ASENSOR_DIRECT_RATE_FAST = 2,
    ASENSOR_DIRECT_RATE_VERY_FAST = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_8 {
    ASENSOR_DIRECT_CHANNEL_TYPE_SHARED_MEMORY = 1,
    ASENSOR_DIRECT_CHANNEL_TYPE_HARDWARE_BUFFER = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_9 {
    ASENSOR_ADDITIONAL_INFO_BEGIN = 0,
    ASENSOR_ADDITIONAL_INFO_END = 1,
    ASENSOR_ADDITIONAL_INFO_UNTRACKED_DELAY = 65536,
    ASENSOR_ADDITIONAL_INFO_INTERNAL_TEMPERATURE = 65537,
    ASENSOR_ADDITIONAL_INFO_VEC3_CALIBRATION = 65538,
    ASENSOR_ADDITIONAL_INFO_SENSOR_PLACEMENT = 65539,
    ASENSOR_ADDITIONAL_INFO_SAMPLING = 65540,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ASensorVector__bindgen_ty_1 {
    pub v: [f32; 3usize],
    pub __bindgen_anon_1: ASensorVector__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: ASensorVector__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AUncalibratedEvent__bindgen_ty_1 {
    pub uncalib: [f32; 3usize],
    pub __bindgen_anon_1: AUncalibratedEvent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AUncalibratedEvent__bindgen_ty_2 {
    pub bias: [f32; 3usize],
    pub __bindgen_anon_1: AUncalibratedEvent__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AAdditionalInfoEvent__bindgen_ty_1 {
    pub data_int32: [i32; 14usize],
    pub data_float: [f32; 14usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ALimitedAxesImuEvent__bindgen_ty_1 {
    pub calib: [f32; 3usize],
    pub __bindgen_anon_1: ALimitedAxesImuEvent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ALimitedAxesImuEvent__bindgen_ty_2 {
    pub supported: [f32; 3usize],
    pub __bindgen_anon_1: ALimitedAxesImuEvent__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ALimitedAxesImuUncalibratedEvent__bindgen_ty_1 {
    pub uncalib: [f32; 3usize],
    pub __bindgen_anon_1: ALimitedAxesImuUncalibratedEvent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ALimitedAxesImuUncalibratedEvent__bindgen_ty_2 {
    pub bias: [f32; 3usize],
    pub __bindgen_anon_1: ALimitedAxesImuUncalibratedEvent__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ALimitedAxesImuUncalibratedEvent__bindgen_ty_3 {
    pub supported: [f32; 3usize],
    pub __bindgen_anon_1: ALimitedAxesImuUncalibratedEvent__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ASensorEvent__bindgen_ty_1 {
    pub __bindgen_anon_1: ASensorEvent__bindgen_ty_1__bindgen_ty_1,
    pub u64_: ASensorEvent__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ASensorEvent__bindgen_ty_1__bindgen_ty_1 {
    pub data: [f32; 16usize],
    pub vector: ASensorVector,
    pub acceleration: ASensorVector,
    pub gyro: ASensorVector,
    pub magnetic: ASensorVector,
    pub temperature: f32,
    pub distance: f32,
    pub light: f32,
    pub pressure: f32,
    pub relative_humidity: f32,
    pub uncalibrated_acceleration: AUncalibratedEvent,
    pub uncalibrated_gyro: AUncalibratedEvent,
    pub uncalibrated_magnetic: AUncalibratedEvent,
    pub meta_data: AMetaDataEvent,
    pub heart_rate: AHeartRateEvent,
    pub dynamic_sensor_meta: ADynamicSensorEvent,
    pub additional_info: AAdditionalInfoEvent,
    pub head_tracker: AHeadTrackerEvent,
    pub limited_axes_imu: ALimitedAxesImuEvent,
    pub limited_axes_imu_uncalibrated: ALimitedAxesImuUncalibratedEvent,
    pub heading: AHeadingEvent,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ASensorEvent__bindgen_ty_1__bindgen_ty_2 {
    pub data: [u64; 8usize],
    pub step_counter: u64,
}
extern "C" {
    pub fn ALooper_forThread() -> *mut ALooper;
    pub fn ALooper_prepare(opts: libc::c_int) -> *mut ALooper;
    pub fn ALooper_acquire(looper: *mut ALooper);
    pub fn ALooper_release(looper: *mut ALooper);
    pub fn ALooper_pollOnce(
        timeoutMillis: libc::c_int,
        outFd: *mut libc::c_int,
        outEvents: *mut libc::c_int,
        outData: *mut *mut libc::c_void,
    ) -> libc::c_int;
    pub fn ALooper_pollAll(
        timeoutMillis: libc::c_int,
        outFd: *mut libc::c_int,
        outEvents: *mut libc::c_int,
        outData: *mut *mut libc::c_void,
    ) -> libc::c_int;
    pub fn ALooper_wake(looper: *mut ALooper);
    pub fn ALooper_addFd(
        looper: *mut ALooper,
        fd: libc::c_int,
        ident: libc::c_int,
        events: libc::c_int,
        callback: ALooper_callbackFunc,
        data: *mut libc::c_void,
    ) -> libc::c_int;
    pub fn ALooper_removeFd(looper: *mut ALooper, fd: libc::c_int) -> libc::c_int;
    pub fn ASensorManager_getInstance() -> *mut ASensorManager;
    pub fn ASensorManager_getInstanceForPackage(
        packageName: *const libc::c_char,
    ) -> *mut ASensorManager;
    pub fn ASensorManager_getSensorList(
        manager: *mut ASensorManager,
        list: *mut ASensorList,
    ) -> libc::c_int;
    pub fn ASensorManager_getDynamicSensorList(
        manager: *mut ASensorManager,
        list: *mut ASensorList,
    ) -> isize;
    pub fn ASensorManager_getDefaultSensor(
        manager: *mut ASensorManager,
        type_: libc::c_int,
    ) -> *const ASensor;
    pub fn ASensorManager_getDefaultSensorEx(
        manager: *mut ASensorManager,
        type_: libc::c_int,
        wakeUp: bool,
    ) -> *const ASensor;
    pub fn ASensorManager_createEventQueue(
        manager: *mut ASensorManager,
        looper: *mut ALooper,
        ident: libc::c_int,
        callback: ALooper_callbackFunc,
        data: *mut libc::c_void,
    ) -> *mut ASensorEventQueue;
    pub fn ASensorManager_destroyEventQueue(
        manager: *mut ASensorManager,
        queue: *mut ASensorEventQueue,
    ) -> libc::c_int;
    pub fn ASensorManager_createSharedMemoryDirectChannel(
        manager: *mut ASensorManager,
        fd: libc::c_int,
        size: usize,
    ) -> libc::c_int;
    pub fn ASensorManager_createHardwareBufferDirectChannel(
        manager: *mut ASensorManager,
        buffer: *const AHardwareBuffer,
        size: usize,
    ) -> libc::c_int;
    pub fn ASensorManager_destroyDirectChannel(
        manager: *mut ASensorManager,
        channelId: libc::c_int,
    );
    pub fn ASensorManager_configureDirectReport(
        manager: *mut ASensorManager,
        sensor: *const ASensor,
        channelId: libc::c_int,
        rate: libc::c_int,
    ) -> libc::c_int;
    pub fn ASensorEventQueue_registerSensor(
        queue: *mut ASensorEventQueue,
        sensor: *const ASensor,
        samplingPeriodUs: i32,
        maxBatchReportLatencyUs: i64,
    ) -> libc::c_int;
    pub fn ASensorEventQueue_enableSensor(
        queue: *mut ASensorEventQueue,
        sensor: *const ASensor,
    ) -> libc::c_int;
    pub fn ASensorEventQueue_disableSensor(
        queue: *mut ASensorEventQueue,
        sensor: *const ASensor,
    ) -> libc::c_int;
    pub fn ASensorEventQueue_setEventRate(
        queue: *mut ASensorEventQueue,
        sensor: *const ASensor,
        usec: i32,
    ) -> libc::c_int;
    pub fn ASensorEventQueue_hasEvents(queue: *mut ASensorEventQueue) -> libc::c_int;
    pub fn ASensorEventQueue_getEvents(
        queue: *mut ASensorEventQueue,
        events: *mut ASensorEvent,
        count: usize,
    ) -> isize;
    pub fn ASensorEventQueue_requestAdditionalInfoEvents(
        queue: *mut ASensorEventQueue,
        enable: bool,
    ) -> libc::c_int;
    pub fn ASensor_getName(sensor: *const ASensor) -> *const libc::c_char;
    pub fn ASensor_getVendor(sensor: *const ASensor) -> *const libc::c_char;
    pub fn ASensor_getType(sensor: *const ASensor) -> libc::c_int;
    pub fn ASensor_getResolution(sensor: *const ASensor) -> f32;
    pub fn ASensor_getMinDelay(sensor: *const ASensor) -> libc::c_int;
    pub fn ASensor_getFifoMaxEventCount(sensor: *const ASensor) -> libc::c_int;
    pub fn ASensor_getFifoReservedEventCount(sensor: *const ASensor) -> libc::c_int;
    pub fn ASensor_getStringType(sensor: *const ASensor) -> *const libc::c_char;
    pub fn ASensor_getReportingMode(sensor: *const ASensor) -> libc::c_int;
    pub fn ASensor_isWakeUpSensor(sensor: *const ASensor) -> bool;
    pub fn ASensor_isDirectChannelTypeSupported(
        sensor: *const ASensor,
        channelType: libc::c_int,
    ) -> bool;
    pub fn ASensor_getHighestDirectReportRateLevel(sensor: *const ASensor) -> libc::c_int;
    pub fn ASensor_getHandle(sensor: *const ASensor) -> libc::c_int;
}
